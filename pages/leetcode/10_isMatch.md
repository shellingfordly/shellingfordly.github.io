---
title: 10. 正则表达式匹配
date: 2022-09-17 10:02:27
tags:
  - algorithms
---

# 10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.'  和  '\*'  的正则表达式匹配。

- '.' 匹配任意单个字符
- '\*' 匹配零个或多个前面的那一个元素
  所谓匹配，是要涵盖 `整个` 字符串 s 的，而不是部分字符串。

- 示例 1：

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

- 示例 2:

```
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

- 示例  3：

```
输入：s = "ab", p = "._"
输出：true
```

解释：`".*"` 表示可匹配零个或多个（`'*'`）任意字符（`'.'`）。

- 提示：

```
1 <= s.length <= 20
1 <= p.length <= 30
s  只包含从  a-z  的小写字母。
p  只包含从  a-z  的小写字母，以及字符  .  和  *。
保证每次出现字符  * 时，前面都匹配到有效的字符
```

## 思路

这题真的有点难，动态规划也是我的弱项。尝试了一下，实在做不出来，直接看题解了。

[宫水三叶的题解](https://leetcode.cn/problems/regular-expression-matching/solution/shua-chuan-lc-dong-tai-gui-hua-jie-fa-by-zn9w/)

分析一下，p 字符有三种情况：

- 普通字符：需要和 s 中同一位置字符完全匹配
- `.`：匹配同一位置任意字符
- `*`
  - 不能单独使用
  - 前面有字符，匹配 s 中同一位置字符任意次

### 动态规划推导

- 状态定义

`dp(i, j)` 代表 s 中 `0-i` 的子串，p 中 `0-j` 的子串是否匹配。即最终我们要求的结果为 `dp(n, m)`。

- 状态转移

1. `p[j]` 为普通字符

匹配条件是前面的字符匹配，同时 s 中第 i 个字符等于 p 中第 j 个字符。即 `dp(i, j) == dp(i-1, j-1) && s[i] == p[j]`

2. `p[j]` 为 '.'

匹配条件是前面的字符匹配，s 中第 i 个字符可以是任意字符。即 `dp(i, j) = dp(i-1, j-1) && p[j] == '.'`。

3. `p[j]` 为 '\*'

- 匹配 0 个字符：dp(i, j) = dp(i, j-2)
- 匹配 1 个字符：dp(i, j) = dp(i-1, j-2) && s[i] == p[j-1] || p[j-1] == '.'
- 匹配 2 个字符：dp(i, j) = dp(i-2, j-2) && s[i] ==p[j-1]
  && s[i-1] == p[j-1] || p[j-1] == '.'

## 代码

```ts
export function isMatch(s: string, p: string): boolean {
  // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始，而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去
  const n = s.length,
    m = p.length;
  s = " " + s;
  p = " " + p;
  // f(i,j) 代表考虑 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配
  const f = Array(n + 1)
    .fill([])
    .map((_) => Array(m + 1).fill(false));

  f[0][0] = true;
  for (let i = 0; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      // 如果下一个字符是 '*'，则代表当前字符不能被单独使用，跳过
      if (j + 1 <= m && p[j + 1] == "*") continue;

      if (i - 1 >= 0 && p[j] != "*") {
        // 对应了 p[j] 为普通字符和 '.' 的两种情况
        f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == ".");
      } else if (p[j] == "*") {
        // 对应了 p[j] 为 '*' 的情况
        f[i][j] =
          (j - 2 >= 0 && f[i][j - 2]) ||
          (i - 1 >= 0 && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == "."));
      }
    }
  }
  return f[n][m];
}
```
