---
title: 22. 括号生成
date: 2022-09-17 10:02:27
tags:
  - algorithms
---

# 22. 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

- 示例 1：

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

- 示例 2：

```
输入：n = 1
输出：["()"]
```

- 提示：

```
1 <= n <= 8
```

## 题解

思路很简单，首先先列出 123 对括号的组合情况

```js
// 1
()
// 2
()() (())
// 3
()()() (())() ()(()) (()()) ((()))
```

从前三组情况中不难，从 1 对括号可以很容易得到 2 对的情况，再 1 情况左边和内部加一对"()"就得到了 2 对的情况；同理在 2 的左边中间后面加一对"()"能组合成 3 对的所有列子。

因此，我们可以知道，n 对括号的组合可以从 n-1 对括号的组合上一对"()"来得到；

那怎么插入呢，很简单，完全不去考虑重复的问题，将"()"从 n-1 的每一种组合情况的 0 位置加到 length 的位置；

- 从 1 对到 2 对的移动情况

```js
1. () 的基础上添加
()()
(())
()() // 重复
```

- 从 2 对到 3 对的移动情况

```js

1. ()() 的基础上添加
()()()
(())()
()()() // 重复
()(())
()()() // 重复
2. (()) 的基础上添加
()(()) // 重复
(()())
((()))
(()()) // 重复
(())() // 重复
```

我们可以利用 js 中 Set 的特性来去重

```ts
function generateParenthesis(n: number): string[] {
  function fn(n: number) {
    // 1对的情况直接返回
    if (n === 1) return new Set(["()"]);
    // 利用set去重
    const result = new Set<string>();
    // 获取n-1的所有组合情况
    const list = fn(n - 1);
    // 遍历n-1所有组合情况
    list.forEach((item) => {
      // 从字符串 0-length 下标逐个添加，所有情况全部添加
      for (let j = 0; j < item.length; j++) {
        result.add(`${item.slice(0, j)}()${item.slice(j)}`);
      }
    });
    return result;
  }
  const res = fn(n);

  return [...res];
}
```
